#!/usr/bin/env python3
import argparse, socket, ssl, json
import random

def arg_parse():
    parsed = argparse.ArgumentParser(description="Wordle client")
    parsed.add_argument("-p", type=int, help="server port")
    parsed.add_argument("-s", action="store_true", dest="use_tls",
                        help="use TLS implies default port 27994")
    parsed.add_argument("hostname", help="proj1.4700.network")
    parsed.add_argument("username", help="valerjev.s")
    
    return parsed.parse_args()

def socket_connection(hostname, port, use_tls):
    skt = socket.create_connection((hostname, port))
    
    if use_tls:
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        skt = ssl_context.wrap_socket(skt, server_hostname=hostname)

    return skt

def send_json_msg(skt, obj):
    data = json.dumps(obj, separators=(",", ":")) + "\n"
    skt.sendall(data.encode("ascii"))

def receive_json_msg(skt):
    buf = bytearray()
    while True:
        check = skt.recv(1)
        if not check:
            raise ConnectionError("Server closed connection")
        if check == b"\n":
            break
        buf.extend(check)
    return json.loads(buf.decode("ascii"))

def play(hostname, user, port, tls, words):
    skt = socket_connection(hostname, port, tls)
    send_json_msg(skt, {"type": "hello", "northeastern_username": user})
    start = receive_json_msg(skt)
    assert start["type"] == "start"
    game = start["id"]

    previous = []
    while True:
        guess = guess_next(previous, words)
        send_json_msg(skt, {"type": "guess", "id": game, "word": guess})

        response = receive_json_msg(skt)
        if response["type"] == "retry":
            previous = response["guesses"]
        elif response["type"] == "bye":
            skt.close()
            return response["flag"]
        else:
            raise RuntimeError(f"server error: {response}")

def find_marks(secret, guess):
    marks = [0] * 5
    letters = list(secret)

    for i in range(5):
        if guess[i] == secret[i]:
            marks[i] = 2
            letters[i] = None
    for i in range(5):
        if marks[i] == 0 and guess[i] in letters:
            marks[i] = 1
            letters[letters.index(guess[i])] = None
    return marks

def guess_check(word, guess, marks):
    return find_marks(word, guess) == marks

def guess_next(previous, words):
    if not previous:
        return random.choice(words)
    
    possible = []
    for w in words:
        valid_word = True
        for p in previous:
            prev_guess = p["word"]
            prev_marks = p["marks"]
            if not guess_check(w, prev_guess, prev_marks):
                valid_word = False
                break
        if valid_word:
            possible.append(w)
    if not possible:
        raise RuntimeError("No possible word matches")
    
    return random.choice(possible)
        
def main():
    arguments = arg_parse()

    if arguments.use_tls:
        port = 27994
    else:
        port = 27993

    skt = socket_connection(arguments.hostname, port, arguments.use_tls)

    words_list = []
    with open("words.txt") as f:
        for w in f:
            word = w.strip()
            words_list.append(word)
    
    flag = play(arguments.hostname, arguments.username, port, arguments.use_tls, words_list)
    print(flag)
    skt.close()

if __name__ == "__main__":
    main()
